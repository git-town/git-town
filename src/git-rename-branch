#!/usr/bin/env bash
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/helpers/helpers.sh"


function preconditions {
  target_branch_name=$1
  destination_branch_name=$2
  force_parameter=$3

  force_rename=false
  if [ "$force_parameter" == "-f" ]; then
    force_rename=true
  fi

  if [ "$(is_main_branch "$target_branch_name")" = true ]; then
    echo_error_header
    echo_error "The main branch cannot be renamed."
    exit_with_error newline
  fi

  if [ -z "$target_branch_name" ]; then
    echo_error_header
    echo_error "No branch name provided to rename."
    exit_with_error newline
  fi

  if [ "$target_branch_name" != "$INITIAL_BRANCH_NAME" ]; then
    ensure_has_branch "$target_branch_name"
  fi

  echo $force_rename
  if [ "$force_rename" = false ]; then
    ensure_is_feature_branch "$target_branch_name" "Run 'git rename-branch $target_branch_name $destination_branch_name -f' to force the rename, then reconfigure git-town on any other clones of this repo."
  fi

  if [ -z "$destination_branch_name" ]; then
    echo_error_header
    echo_error "No branch name provided to rename to."
    exit_with_error newline
  fi

  if [ "$HAS_REMOTE" = true ]; then
    fetch
  fi

  ensure_does_not_have_branch "$destination_branch_name"
}


function steps {
  echo_if_true "stash_open_changes" "$INITIAL_OPEN_CHANGES"
  echo "create_and_checkout_branch '$destination_branch_name' '$target_branch_name'"

  if [ "$(has_tracking_branch "$target_branch_name")" = true ]; then =
    echo "push"
    echo "delete_remote_branch $target_branch_name"
  fi

  echo "delete_local_branch '$target_branch_name' force"

  if [ "$(is_non_feature_branch "$target_branch_name")" = true ]; then
    local new_branches=$(remove_string "$NON_FEATURE_BRANCH_NAMES" ',' "$target_branch_name")
    new_branches=$(insert_string "$new_branches" ',' "$destination_branch_name")
    store_configuration non-feature-branch-names "$new_branches"
  fi

  echo_if_true "restore_open_changes" "$INITIAL_OPEN_CHANGES"
}


run "$@"
