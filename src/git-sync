#!/usr/bin/env bash
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/helpers/helpers.sh"


# Echoes the names of all branches that should be synced in the current session
function branches_to_sync {
  if [ "$sync_all" = true ]; then
    echo "$MAIN_BRANCH_NAME"
    local_branches_without_main
  elif [ "$(is_feature_branch "$INITIAL_BRANCH_NAME")" = true ]; then
    # syncing a feature branch here
    parent_branches "$INITIAL_BRANCH_NAME"
    echo "$INITIAL_BRANCH_NAME"
  else
    # syncing a non-feature branch
    echo "$INITIAL_BRANCH_NAME"
  fi
}


function preconditions {
  if [ "$HAS_REMOTE" = true ]; then
    fetch
  fi

  should_push_tags=false
  sync_all=false

  if [ "$1" = "--all" ]; then
    sync_all=true
  elif [ "$(is_feature_branch "$INITIAL_BRANCH_NAME")" = false ]; then
    # syncing a non-feature branch
    should_push_tags=true
  else
    # syncing a feature branch
    ensure_knows_parent_branches "$INITIAL_BRANCH_NAME"
  fi
}


# Makes sure that we know all the parent branches
# Asks the user if necessary
# Aborts the script if not all branches become known.
function ensure_knows_parent_branches {
  local current_branch=$1
  if [ "$(knows_all_parent_branches "$current_branch")" = false ]; then
    # Here we don't have the parent branches list --> make sure we know all parents, then recompile it from all parents
    local parent

    while [ "$current_branch" != "$MAIN_BRANCH_NAME" ]; do
      if [ "$(knows_parent_branch "$current_branch")" = true ]; then
        parent=$(parent_branch "$current_branch")
        echo "automatically determined parent as '$parent'"
      else
        # here we don't know the parent of the current branch -> ask the user
        echo
        echo -n "Please enter the parent branch for $(echo_n_cyan_bold "$current_branch") ($(echo_n_dim "$MAIN_BRANCH_NAME")): "
        read parent
        if [ -z "$parent" ]; then
          parent=$MAIN_BRANCH_NAME
        fi
        if [ "$(has_branch "$parent")" == "false" ]; then
          echo_error_header
          echo_error "branch '$parent' doesn't exist"
          exit_with_error newline
        fi
        store_parent_branch "$current_branch" "$parent"
      fi
      current_branch=$parent
    done
    compile_parent_branches "$1"
  fi
}


function skip_message_prefix {
  echo "To skip the sync of the '$(get_current_branch_name)' branch"
}


function skippable {
  if [ "$(rebase_in_progress)" = true ] && [ "$(get_current_branch_name)" = "$MAIN_BRANCH_NAME" ]; then
    echo false
  else
    echo true
  fi
}


function steps {
  echo_if_true "change_directory $(git_root)" "$IN_SUB_FOLDER"
  echo_if_true "stash_open_changes" "$INITIAL_OPEN_CHANGES"

  branches_to_sync | while read branch_name; do
    local is_feature
    is_feature="$(is_feature_branch "$branch_name")"

    # If there is a remote origin, then checkout and sync all branches because
    # there may be changes to non-feature branches, otherwise only sync feature
    # branches because non-feature branches will not need syncing
    if [ "$HAS_REMOTE" = true ] || [ "$is_feature" = true ]; then
      echo "checkout $branch_name"

      if [ "$is_feature" = true ]; then
        echo "merge_tracking_branch"
        echo "merge $(parent_branch "$branch_name")"
      else
        echo "rebase_tracking_branch"
      fi

      echo_if_true "push" "$HAS_REMOTE"
    fi
  done

  if [ "$HAS_REMOTE" = true ] && [ "$should_push_tags" = true ]; then
    echo "push_tags"
  fi

  echo "checkout $INITIAL_BRANCH_NAME"

  echo_if_true "restore_open_changes" "$INITIAL_OPEN_CHANGES"
  echo_if_true "change_directory $INITIAL_DIRECTORY" "$IN_SUB_FOLDER"
}


run "$@"
