"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const search_list_1 = require("./search-list");
const regex_search_1 = require("./searches/regex-search");
const string_search_1 = require("./searches/string-search");
const text_accumulator_1 = require("./text-accumulator");
/**
 * TextStreamSearch searches ReadableStreams for text and regexes.
 */
class TextStreamSearch {
    constructor(stream) {
        this.streamText = new text_accumulator_1.TextAccumulator();
        this.searchList = new search_list_1.SearchList();
        stream.on("data", this.onStreamData.bind(this));
    }
    /** Fulltext returns the complete content captured from this stream so far. */
    fullText() {
        return this.streamText.toString();
    }
    /**
     * WaitForText returns a promise that resolves with the matching text
     * when the given text shows up in the observed stream.
     * If a timeout is given, aborts after the given duration.
     */
    waitForText(text, timeout) {
        return new Promise((resolve, reject) => {
            this.searchList.push(new string_search_1.StringSearch(text, resolve, reject, this.streamText, timeout));
            this.searchList.scan();
        });
    }
    /**
     * WaitForRegex returns a promise that resolves with the matching text
     * when the given RegExp shows up in observed stream.
     * If a timeout is given, aborts after the given duration.
     */
    waitForRegex(regex, timeout) {
        return new Promise((resolve, reject) => {
            this.searchList.push(new regex_search_1.RegexSearch(regex, resolve, reject, this.streamText, timeout));
            this.searchList.scan();
        });
    }
    /** OnStreamData is called when new text arrives on the input stream. */
    onStreamData(data) {
        this.streamText.push(data.toString());
        this.searchList.scan();
    }
}
exports.TextStreamSearch = TextStreamSearch;
