"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = __importStar(require("child_process"));
const delay_1 = __importDefault(require("delay"));
const merge_stream_1 = __importDefault(require("merge-stream"));
const string_argv_1 = __importDefault(require("string-argv"));
const searchable_stream_1 = require("./searchable-stream");
/** starts a new ObservableProcess with the given options */
function createObservableProcess(command, args = {}) {
    // determine args
    let argv = [];
    if (!command) {
        throw new Error("createObservableProcess: no command to execute given");
    }
    if (typeof command === "string") {
        argv = string_argv_1.default(command);
    }
    else if (Array.isArray(command)) {
        argv = command;
    }
    else {
        throw new Error("observable.spawn: you must provide the command to run as a string or string[]");
    }
    const [runnable, ...params] = argv;
    // start the process
    return new ObservableProcess({
        cwd: args.cwd || process.cwd(),
        env: args.env || process.env,
        params,
        runnable
    });
}
exports.createObservableProcess = createObservableProcess;
/** a long-running process whose behavior can be observed at runtime */
class ObservableProcess {
    constructor(args) {
        this.ended = false;
        this.killed = false;
        this.endedListeners = [];
        this.exitCode = null;
        this.process = childProcess.spawn(args.runnable, args.params, {
            cwd: args.cwd,
            env: args.env
        });
        this.process.on("close", this.onClose.bind(this));
        if (this.process.stdin == null) {
            throw new Error("process.stdin should not be null");
        }
        this.stdin = this.process.stdin;
        if (this.process.stdout == null) {
            throw new Error("process.stdout should not be null");
        }
        this.stdout = searchable_stream_1.createSearchableStream(this.process.stdout);
        if (this.process.stderr == null) {
            throw new Error("process.stderr should not be null");
        }
        this.stderr = searchable_stream_1.createSearchableStream(this.process.stderr);
        const outputStream = merge_stream_1.default(this.process.stdout, this.process.stderr);
        this.output = searchable_stream_1.createSearchableStream(outputStream);
    }
    /** stops the currently running process */
    kill() {
        return __awaiter(this, void 0, void 0, function* () {
            this.killed = true;
            this.process.kill();
            yield delay_1.default(0);
        });
    }
    /** returns the process ID of the underlying ChildProcess */
    pid() {
        return this.process.pid;
    }
    /** returns a promise that resolves when the underlying ChildProcess terminates */
    waitForEnd() {
        return new Promise(resolve => {
            this.endedListeners.push(resolve);
        });
    }
    /** called when the underlying ChildProcess terminates */
    onClose(exitCode) {
        this.ended = true;
        this.exitCode = exitCode;
        for (const resolver of this.endedListeners) {
            resolver();
        }
    }
}
exports.ObservableProcess = ObservableProcess;
