"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const slugify_1 = __importDefault(require("@sindresorhus/slugify"));
class LinkTargetList {
    constructor() {
        this.targets = {};
    }
    addNodeList(nodeList) {
        for (const node of nodeList) {
            const key = node.file.platformified();
            this.targets[key] = this.targets[key] || [];
            if (node.type === "anchor_open") {
                this.addAnchor(node);
            }
            else if (/h[1-6]_open/.test(node.type)) {
                this.addHeading(node, nodeList);
            }
        }
    }
    addAnchor(node) {
        if (node.attributes.href !== undefined) {
            return;
        }
        if (!node.attributes.name) {
            return;
        }
        this.addLinkTarget(node.file, "anchor", node.attributes.name);
    }
    addHeading(node, nodeList) {
        const content = nodeList.textInNode(node);
        if (!content) {
            return;
        }
        this.addLinkTarget(node.file, "heading", content);
    }
    addLinkTarget(filePath, type, name) {
        const key = filePath.platformified();
        this.targets[key] = this.targets[key] || [];
        this.targets[key].push({
            name: slugify_1.default(name.toLowerCase()),
            type
        });
    }
    // Returns the type of the given anchor
    // with the given name in the given file
    anchorType(filePath, name) {
        const anchorsForFile = this.targets[filePath.platformified()];
        if (!anchorsForFile) {
            throw new Error(`no anchors in file ${filePath.platformified()}`);
        }
        const anchor = anchorsForFile.find(linkTarget => linkTarget.name === name);
        if (!anchor) {
            throw new Error(`no anchor '${name}' in file '${filePath.platformified()}'`);
        }
        return anchor.type;
    }
    hasAnchor(filePath, name) {
        const fileList = this.targets[filePath.platformified()];
        if (!fileList) {
            return false;
        }
        return fileList.some(linkTarget => linkTarget.name === name);
    }
    // Returns whether this link target list knows about the given file
    hasFile(filePath) {
        return this.targets[filePath.platformified()] != null;
    }
}
exports.LinkTargetList = LinkTargetList;
//# sourceMappingURL=link-target-list.js.map