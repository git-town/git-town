"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const colorette_1 = __importDefault(require("colorette"));
const observable_process_1 = require("observable-process");
const path_1 = __importDefault(require("path"));
const call_args_1 = require("../helpers/call-args");
const running_console_command_1 = require("../helpers/running-console-command");
const trim_dollar_1 = require("../helpers/trim-dollar");
/**
 * The "runConsoleCommand" action runs the given commands on the console
 * and waits until the command is finished.
 */
async function runConsoleCommand(args) {
    const commandsToRun = args.nodes
        .textInNodeOfType("fence")
        .split("\n")
        .map(command => command.trim())
        .filter(e => e)
        .map(trim_dollar_1.trimDollar)
        .map(makeGlobal(args.configuration))
        .join(" && ");
    if (commandsToRun === "") {
        throw new Error("the block that defines console commands to run is empty");
    }
    args.name(`running console command: ${colorette_1.default.cyan(commandsToRun)}`);
    let input = [];
    if (args.nodes.hasNodeOfType("table")) {
        input = getInput(args.nodes);
    }
    // this needs to be global because it is used in the "verify-run-console-output" step
    const processor = observable_process_1.createObservableProcess(call_args_1.callArgs(commandsToRun), {
        cwd: args.configuration.workspace
    });
    running_console_command_1.RunningConsoleCommand.set(processor);
    for (const inputLine of input) {
        enter(processor, inputLine);
    }
    await processor.waitForEnd();
    args.log(processor.output.fullText());
}
exports.default = runConsoleCommand;
async function enter(processor, input) {
    // TODO: reduce redundancy
    if (!input.textToWait) {
        processor.stdin.write(input.input + "\n");
    }
    else {
        await processor.stdout.waitForText(input.textToWait);
        processor.stdin.write(input.input + "\n");
    }
}
function getInput(nodes) {
    const result = [];
    if (!nodes) {
        return result;
    }
    // TODO: simplify this with an "AstNodeList.getSubList" method
    const tbodyNode = nodes.getNodeOfTypes("tbody_open");
    const tbodyContent = nodes.getNodesFor(tbodyNode);
    const trNodes = tbodyContent.getNodesOfTypes("tr_open");
    for (const trNode of trNodes) {
        const trContent = nodes.getNodesFor(trNode);
        if (trContent.length === 0) {
            // empty table row, ignore
            continue;
        }
        const tdNode = trContent.getNodesOfTypes("td_open");
        if (tdNode.length === 0) {
            // no TD found, possibly because there are THs --> ignore
            continue;
        }
        if (tdNode.length === 1) {
            // single-column table, use that column
            const text = trContent.textInNode(tdNode[0]);
            result.push({ textToWait: null, input: text });
        }
        else {
            // multi-colum table, use the last column
            result.push({
                input: trContent.textInNode(tdNode[tdNode.length - 1]),
                textToWait: trContent.textInNode(tdNode[0])
            });
        }
    }
    return result;
}
function makeGlobal(configuration) {
    configuration = configuration || {};
    let globals = {};
    try {
        globals = configuration.actions.runConsoleCommand.globals;
    }
    catch (e) {
        // can ignore errors here
    }
    return function (commandText) {
        const commandParts = commandText.split(" ");
        const command = commandParts[0];
        const replacement = globals[command];
        if (replacement) {
            return path_1.default.join(configuration.sourceDir, replacement) + " " + commandParts.splice(1).join(" ");
        }
        else {
            return commandText;
        }
    };
}
//# sourceMappingURL=run-console-command.js.map