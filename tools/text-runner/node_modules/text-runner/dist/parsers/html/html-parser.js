"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parse5_1 = __importDefault(require("parse5"));
const util_1 = __importDefault(require("util"));
const ast_node_1 = require("../standard-AST/ast-node");
const ast_node_list_1 = require("../standard-AST/ast-node-list");
const standardize_html_attributes_1 = require("./helpers/standardize-html-attributes");
/** HtmlParser converts HTML5 source into the standardized AST format. */
class HTMLParser {
    constructor(tagMapper) {
        this.tagMapper = tagMapper;
    }
    /**
     * Parse returns the standard AST for the given HTML text.
     *
     * @param file The file in which the given text happens (for error messages)
     * @param startingLine The line at which this HTML snippet is located in the source document.
     *                     This parameter helps show correct line numbers for HTML snippets
     *                     that are embedded in Markdown documents.
     */
    parse(text, file, startingLine) {
        const htmlAst = parse5_1.default.parse(text, {
            sourceCodeLocationInfo: true
        });
        return this.standardizeDocument(htmlAst, file, startingLine);
    }
    /** returns whether the given HTML node is an empty text node */
    isEmptyTextNode(node) {
        return node.nodeName === "#text" && node.value.trim() === "";
    }
    /** returns the subtree of the given HTML AST whose root node has the given name */
    findChildWithName(node, name) {
        for (const childNode of node.childNodes) {
            if (childNode.nodeName === name) {
                return childNode;
            }
        }
        throw new Error(`child node '${name}' not found in AST: ${util_1.default.inspect(node)}`);
    }
    /**
     * converts the given HTML AST for an entire HTML document into the standard AST
     */
    standardizeDocument(documentAst, file, startingLine = 1) {
        const result = new ast_node_list_1.AstNodeList();
        const htmlNode = this.findChildWithName(documentAst, "html");
        const bodyNode = this.findChildWithName(htmlNode, "body");
        for (const childNode of bodyNode.childNodes) {
            result.push(...this.standardizeNode(childNode, file, startingLine));
        }
        return result;
    }
    /** converts the given HTML AST node into the standard format */
    standardizeNode(node, file, startingLine) {
        if (this.isEmptyTextNode(node)) {
            return new ast_node_list_1.AstNodeList();
        }
        if (node.nodeName === "#text") {
            return this.standardizeTextNode(node, file, startingLine);
        }
        if (this.tagMapper.isStandaloneTag(node.nodeName)) {
            return this.standardizeStandaloneNode(node, file, startingLine);
        }
        return this.standardizeOpenCloseTag(node, file, startingLine);
    }
    /** converts the given HTML tag with open and closing tag into the standard format */
    standardizeOpenCloseTag(node, file, startingLine) {
        const result = new ast_node_list_1.AstNodeList();
        const attributes = standardize_html_attributes_1.standardizeHTMLAttributes(node.attrs);
        // store the opening node
        let startLine = startingLine;
        if (node.sourceCodeLocation) {
            startLine += node.sourceCodeLocation.startLine - 1;
        }
        else if (node.parentNode && node.parentNode.sourceCodeLocation) {
            startLine += node.parentNode.sourceCodeLocation.startLine;
        }
        result.push(new ast_node_1.AstNode({
            attributes,
            content: "",
            file,
            line: startLine,
            tag: node.tagName,
            type: this.tagMapper.openingTypeForTag(node.tagName, attributes)
        }));
        // store the child nodes in between the opening and closing node
        for (const childNode of node.childNodes) {
            const standardizedChildNodes = this.standardizeNode(childNode, file, startingLine);
            result.push(...standardizedChildNodes);
        }
        // store the closing node
        let endLine;
        if (node.sourceCodeLocation) {
            endLine = node.sourceCodeLocation.endLine + startingLine - 1;
        }
        else if (node.parentNode && node.parentNode.sourceCodeLocation) {
            endLine = node.parentNode.sourceCodeLocation.endLine + startingLine - 1;
        }
        else {
            throw new Error(`cannot determine end line for node ${node}`);
        }
        if (!node.sourceCodeLocation || (node.sourceCodeLocation && node.sourceCodeLocation.endTag)) {
            const tag = "/" + node.tagName;
            result.push(new ast_node_1.AstNode({
                attributes: {},
                content: "",
                file,
                line: endLine,
                tag,
                type: this.tagMapper.typeForTag(tag, attributes)
            }));
        }
        return result;
    }
    /** converts the given HTML standalone node into the standard format */
    standardizeStandaloneNode(node, file, startingLine) {
        const result = new ast_node_list_1.AstNodeList();
        const attributes = standardize_html_attributes_1.standardizeHTMLAttributes(node.attrs);
        result.push(new ast_node_1.AstNode({
            attributes,
            content: "",
            file,
            line: node.sourceCodeLocation.startLine + startingLine - 1,
            tag: node.tagName || "",
            type: this.tagMapper.typeForTag(node.tagName, attributes)
        }));
        return result;
    }
    /** converts the given HTML text node into the standard format */
    standardizeTextNode(node, file, startingLine) {
        const result = new ast_node_list_1.AstNodeList();
        if (node.value !== "\n") {
            result.push(new ast_node_1.AstNode({
                attributes: {},
                content: node.value.trim(),
                file,
                line: node.sourceCodeLocation.startLine + startingLine - 1,
                tag: node.tagName || "",
                type: "text"
            }));
        }
        return result;
    }
}
exports.HTMLParser = HTMLParser;
//# sourceMappingURL=html-parser.js.map