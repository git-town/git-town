// Generated by LiveScript 1.5.0
var ref$, bold, green, red, child_process, EventEmitter, fs, compact, last, wait, PipeListener;
ref$ = require('chalk'), bold = ref$.bold, green = ref$.green, red = ref$.red;
child_process = require('child_process');
EventEmitter = require('events');
fs = require('fs');
ref$ = require('prelude-ls'), compact = ref$.compact, last = ref$.last;
wait = require('wait').wait;
PipeListener = (function(superclass){
  var prototype = extend$((import$(PipeListener, superclass).displayName = 'PipeListener', PipeListener), superclass).prototype, constructor = PipeListener;
  function PipeListener(pipePath){
    this.pipePath = pipePath;
    this.started = false;
  }
  PipeListener.prototype.cleanup = function(){
    var ref$;
    switch (false) {
    case !!this.started:
      return;
    }
    this.killed = true;
    if ((ref$ = this.listener) != null) {
      ref$.kill();
    }
    return this.deleteNamedPipe();
  };
  PipeListener.prototype.createNamedPipe = function(){
    return child_process.execSync("mkfifo " + this.pipePath);
  };
  PipeListener.prototype.deleteNamedPipe = function(){
    try {
      return fs.unlinkSync(this.pipePath);
    } catch (e$) {}
  };
  PipeListener.prototype.emptyNamedPipe = function(done){
    var doneCalled, exit;
    switch (false) {
    case !!this.existsNamedPipe():
      return done();
    }
    doneCalled = false;
    exit = function(){
      switch (false) {
      case !doneCalled:
        return;
      }
      doneCalled = true;
      return done();
    };
    child_process.exec("cat " + this.pipePath, exit);
    return wait(0, exit);
  };
  PipeListener.prototype.existsNamedPipe = function(){
    var e;
    try {
      fs.statSync(this.pipePath);
      return true;
    } catch (e$) {
      e = e$;
      return false;
    }
  };
  PipeListener.prototype.listen = function(done){
    var this$ = this;
    return this.resetNamedPipe(function(){
      this$.createNamedPipe();
      this$.openReadStream();
      this$.started = true;
      return done();
    });
  };
  PipeListener.prototype.openReadStream = function(){
    var this$ = this;
    return this.listener = child_process.exec("cat " + this.pipePath, function(err, stdout, stderr){
      var commandString, command, error;
      switch (false) {
      case !this$.killed:
        return;
      case !err:
        return this$.emit('error', err);
      }
      commandString = last(
      compact(
      stdout.split('\n')));
      try {
        command = JSON.parse(commandString);
      } catch (e$) {
        error = e$;
        this$.emit('command-parse-error', "Invalid command: " + stdout + "\n" + error);
        this$.openReadStream();
        return;
      }
      this$.emit('command-received', command);
      return this$.openReadStream();
    });
  };
  PipeListener.prototype.resetNamedPipe = function(done){
    var this$ = this;
    switch (false) {
    case !!this.existsNamedPipe():
      return done();
    }
    return this.emptyNamedPipe(function(){
      this$.deleteNamedPipe();
      return done();
    });
  };
  return PipeListener;
}(EventEmitter));
module.exports = PipeListener;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}