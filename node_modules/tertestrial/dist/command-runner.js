// Generated by LiveScript 1.5.0
var ref$, bold, cyan, green, red, spawn, error, fileType, fillTemplate, resetTerminal, path, filter, findIndex, sortBy, util, CommandRunner, toString$ = {}.toString, slice$ = [].slice;
ref$ = require('chalk'), bold = ref$.bold, cyan = ref$.cyan, green = ref$.green, red = ref$.red;
spawn = require('child_process').spawn;
error = require('./helpers/error-message').error;
fileType = require('./helpers/file-type');
fillTemplate = require('./helpers/fill-template');
resetTerminal = require('./helpers/reset-terminal');
path = require('path');
ref$ = require('prelude-ls'), filter = ref$.filter, findIndex = ref$.findIndex, sortBy = ref$.sortBy;
util = require('util');
CommandRunner = (function(){
  CommandRunner.displayName = 'CommandRunner';
  var prototype = CommandRunner.prototype, constructor = CommandRunner;
  function CommandRunner(config){
    this.config = config;
    this._getTemplate = bind$(this, '_getTemplate', prototype);
    this.runCommand = bind$(this, 'runCommand', prototype);
    this.currentActionSet = this.config.actions[0];
    this.currentActionSetIndex = 0;
    this.currentCommand = '';
    this.currentProcess = null;
  }
  CommandRunner.prototype.runCommand = function(command, done){
    var ref$;
    resetTerminal();
    if (command.actionSet) {
      this.currentActionSetIndex = this.standardizeActionSetIndex(command.actionSet);
      this.setActionset(done);
      return;
    }
    if (command.cycleActionSet === 'next') {
      this.currentActionSetIndex = (this.currentActionSetIndex + 1) % this.config.actions.length;
      this.setActionset(done);
      return;
    }
    if (command.repeatLastTest) {
      if (((ref$ = this.currentCommand) != null ? ref$.length : void 8) === 0) {
        return error("No previous test run");
      }
      this.reRunLastTest(done);
      return;
    }
    if (command.filename) {
      command.filename = path.relative(process.cwd(), command.filename);
    }
    this.currentCommand = command;
    return this.reRunLastTest(done);
  };
  CommandRunner.prototype.reRunLastTest = function(done){
    var template;
    if (!(template = this._getTemplate(this.currentCommand))) {
      return error("no matching action found for " + JSON.stringify(this.currentCommand));
    }
    return this._runTest(fillTemplate(template, this.currentCommand), done);
  };
  CommandRunner.prototype.setActionset = function(done){
    switch (false) {
    case this.currentActionSetIndex != null:
      return;
    }
    this.currentActionSet = this.config.actions[this.currentActionSetIndex];
    console.log("Activating action set " + cyan(this.currentActionSet.name) + "\n");
    if (this.currentCommand) {
      return this.reRunLastTest(done);
    } else {
      return typeof done == 'function' ? done() : void 8;
    }
  };
  CommandRunner.prototype.standardizeActionSetIndex = function(actionSetId){
    var type, index, this$ = this;
    switch (type = toString$.call(actionSetId).slice(8, -1)) {
    case 'Number':
      if (actionSetId < 1 || actionSetId > this.config.actions.length) {
        return error("action set " + cyan(actionSetId) + " does not exist");
      } else {
        return actionSetId - 1;
      }
      break;
    case 'String':
      index = findIndex(function(it){
        return it.name === actionSetId;
      })(
      this.config.actions);
      if (index != null) {
        return index;
      } else {
        return error("action set " + cyan(actionSetId) + " does not exist");
      }
      break;
    default:
      return error("unsupported action-set id type: " + type);
    }
  };
  CommandRunner.prototype.updateConfig = function(config){
    this.config = config;
    return this.setActionset(this.currentActionSetId);
  };
  CommandRunner.prototype._getTemplate = function(command){
    var matchingActions;
    if ((matchingActions = this._getMatchingActions(command)).length === 0) {
      return null;
    }
    return matchingActions[matchingActions.length - 1].command;
  };
  CommandRunner.prototype._getMatchingActions = function(command){
    var this$ = this;
    return sortBy(function(it){
      return it.length;
    })(
    filter(partialize$.apply(this, [this._isMatch, [void 8, command], [0]]))(
    this.currentActionSet.matches));
  };
  CommandRunner.prototype._actionHasEmptyMatch = function(action){
    return !action.match;
  };
  CommandRunner.prototype._isMatch = function(action, command){
    var key, ref$, value, ref1$;
    if (this._isNonEmptyCommand(command) && this._actionHasEmptyMatch(action)) {
      return false;
    }
    for (key in ref$ = action.match) {
      value = ref$[key];
      if (!((ref1$ = action.match[key]) != null && ref1$.exec(command[key]))) {
        return false;
      }
    }
    return true;
  };
  CommandRunner.prototype._isNonEmptyCommand = function(command){
    return Object.keys(command).length > 0;
  };
  CommandRunner.prototype._runTest = function(command, done){
    var this$ = this;
    return this._stopRunningTest(function(){
      var x$;
      console.log(bold(command + "\n"));
      x$ = this$.currentProcess = spawn('sh', ['-c', command], {
        stdio: 'inherit'
      });
      x$.on('exit', function(code){
        var style;
        style = code === 0 ? green : red;
        return console.log(style("\nexit code: " + code));
      });
      return typeof done == 'function' ? done() : void 8;
    });
  };
  CommandRunner.prototype._stopRunningTest = function(done){
    var ref$, ref1$, x$;
    switch (false) {
    case !!this.currentProcess:
      return done();
    case ((ref$ = this.currentProcess) != null ? ref$.exitCode : void 8) == null:
      return done();
    case !((ref1$ = this.currentProcess) != null && ref1$.killed):
      return done();
    }
    x$ = this.currentProcess;
    x$.on('exit', function(){
      return done();
    });
    x$.kill();
    return x$;
  };
  return CommandRunner;
}());
module.exports = CommandRunner;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function partialize$(f, args, where){
  var context = this;
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ?
      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
  };
}