"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const unprinted_user_error_1 = require("../../errors/unprinted-user-error");
const ast_node_1 = require("./ast-node");
class AstNodeList extends Array {
    /** Creates a new AstNodeList containing an AstNode scaffoldedd from the given data */
    static scaffold(data = {}) {
        const result = new AstNodeList();
        result.push(ast_node_1.AstNode.scaffold(data));
        return result;
    }
    /**
     * Returns the AstNode matching any of the given types.
     * Only one result is expected,
     * multiple or zero matches cause an exception.
     */
    getNodeOfTypes(...nodeTypes) {
        const nodes = this.getNodesOfTypes(...nodeTypes);
        if (nodes.length > 1) {
            throw new unprinted_user_error_1.UnprintedUserError(`Found ${nodes.length} nodes of type '${nodeTypes.join("/")}'`, nodes[0].file.platformified(), nodes[0].line);
        }
        if (nodes.length === 0) {
            let msg = `Found no nodes of type '${nodeTypes.join("/")}'. `;
            msg += "The node types in this list are: ";
            msg += this.nodeTypes().join(", ");
            throw new unprinted_user_error_1.UnprintedUserError(msg, this[0].file.platformified(), this[0].line);
        }
        return nodes[0];
    }
    /**
     * Assuming the given AstNode is an opening node,
     * returns all nodes until it closes.
     */
    getNodesFor(openingNode) {
        if (openingNode == null) {
            throw new unprinted_user_error_1.UnprintedUserError("null Node given");
        }
        let index = this.indexOf(openingNode);
        if (index === -1) {
            throw new unprinted_user_error_1.UnprintedUserError(`node '${openingNode.type}' not found in list`, openingNode.file.platformified(), openingNode.line);
        }
        const result = new AstNodeList();
        if (!openingNode.isOpeningNode()) {
            result.push(openingNode);
            return result;
        }
        const endType = openingNode.endType();
        let node;
        do {
            node = this[index];
            result.push(node);
            index += 1;
        } while (node.type !== endType && index < this.length);
        return result;
    }
    /** Returns the AstNodes matching any of the given types. */
    getNodesOfTypes(...nodeTypes) {
        const result = new AstNodeList();
        const matchingNodes = this.filter(node => nodeTypes.includes(node.type));
        for (const node of matchingNodes) {
            result.push(node);
        }
        return result;
    }
    /** Returns whether this AstNodeList contains a node of the given type. */
    hasNodeOfType(nodeType) {
        const types = [nodeType];
        types.push(nodeType + "_open");
        return this.some(node => types.includes(node.type));
    }
    /** Returns all node types encountered in this list. */
    nodeTypes() {
        return this.map(node => node.type);
    }
    /** Adds a new AstNode with the given data to this list. */
    pushNode(data) {
        this.push(ast_node_1.AstNode.scaffold(data));
    }
    /** Returns the concatenated textual content of all nodes in this list. */
    text() {
        return this.reduce((acc, node) => acc + node.content, "");
    }
    /** Returns the textual content for the given node. */
    textInNode(astNode) {
        return this.getNodesFor(astNode).reduce((acc, node) => acc + node.content, "");
    }
    /**
     * Returns the text in the node of the given types.
     * Expects that exactly one matching node exists,
     * throws otherwise.
     */
    textInNodeOfType(...nodeTypes) {
        for (const nodeType of nodeTypes) {
            if (!nodeType.endsWith("_open")) {
                nodeTypes.push(nodeType + "_open");
            }
        }
        return this.textInNode(this.getNodeOfTypes(...nodeTypes));
    }
    /**
     * Returns the text in the nodes of the given types.
     */
    textInNodesOfType(...nodeTypes) {
        for (const nodeType of nodeTypes) {
            if (!nodeType.endsWith("_open")) {
                nodeTypes.push(nodeType + "_open");
            }
        }
        return this.getNodesOfTypes(...nodeTypes).map(node => this.textInNode(node));
    }
}
exports.AstNodeList = AstNodeList;
//# sourceMappingURL=ast-node-list.js.map