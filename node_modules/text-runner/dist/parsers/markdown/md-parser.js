"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const markdown_it_1 = __importDefault(require("markdown-it"));
const util_1 = __importDefault(require("util"));
const html_parser_1 = require("../html/html-parser");
const ast_node_1 = require("../standard-AST/ast-node");
const ast_node_list_1 = require("../standard-AST/ast-node-list");
const tag_mapper_1 = require("../tag-mapper");
const closing_tag_parser_1 = require("./helpers/closing-tag-parser");
const open_node_tracker_1 = require("./helpers/open-node-tracker");
/** MarkdownParser is a DocumentsParser that parses Markdown. */
class MarkdownParser {
    constructor() {
        this.markdownIt = new markdown_it_1.default({
            html: true,
            linkify: false
        });
        this.tagMapper = new tag_mapper_1.TagMapper();
        this.closingTagParser = new closing_tag_parser_1.ClosingTagParser(this.tagMapper);
        this.htmlParser = new html_parser_1.HTMLParser(this.tagMapper);
    }
    /** returns the standard AST representing the given Markdown text */
    parse(text, file) {
        const mdAST = this.markdownIt.parse(text, {});
        return this.standardizeAST(mdAST, file, 1, new open_node_tracker_1.OpenNodeTracker());
    }
    /** Converts the given MarkdownIt AST into the standard AST format */
    standardizeAST(mdAST, file, parentLine, ont) {
        const result = new ast_node_list_1.AstNodeList();
        let currentLine = parentLine;
        for (const node of mdAST) {
            currentLine = Math.max((node.map || [[0]])[0] + 1, currentLine);
            if (node.type === "image") {
                // need to handle images explicitly here because they have a text node as a child
                // but the AST shouldn't contain it
                result.push(...this.standardizeImageNode(node, file, currentLine));
                continue;
            }
            if (node.children) {
                result.push(...this.standardizeAST(node.children, file, currentLine, ont));
                continue;
            }
            if (node.type === "softbreak") {
                currentLine += 1;
                continue;
            }
            result.push(...this.standardizeNode(node, file, currentLine, ont));
        }
        return result;
    }
    /** Returns the standardized version of the given MarkdownIt node */
    standardizeNode(mdNode, file, line, ont) {
        // ignore empty text nodes
        // to avoid having to deal with this edge case later
        if (mdNode.type === "text" && mdNode.content === "") {
            return new ast_node_list_1.AstNodeList();
        }
        // special handling for headings to make them compatible with their HTML counterparts:
        // - they get renamed from heading_open to h1_open etc
        if (mdNode.type === "heading_open") {
            return this.standardizeHeadingOpen(mdNode, file, line);
        }
        // special handling for headings to make them compatible with their HTML counterparts:
        // - they get renamed from heading_close to h1_close etc
        if (mdNode.type === "heading_close") {
            return this.standardizeHeadingClose(mdNode, file, line);
        }
        // special handling for embedded code blocks to be compatible with its HTML counterpart:
        // - it is unrolled to code_open, text, code_close
        if (mdNode.type === "code_inline") {
            return this.standardizeCodeInline(mdNode, file, line);
        }
        // special handling for fenced code blocks to be compatible with its HTML counterpart:
        // - it is unrolled to fence_open, text, fence_close
        // - the content starts on the line below the opening ```
        if (mdNode.type === "fence") {
            return this.standardizeFence(mdNode, file, line);
        }
        // special handling for indented code blocks to be compatible with their HTML counterpart:
        // - they are expanded to fence_open, text, fence_close
        if (mdNode.type === "code_block") {
            return this.standardizeEmbeddedCodeblock(mdNode, file, line);
        }
        // handle embedded HTML
        if (mdNode.type === "html_inline" || mdNode.type === "html_block") {
            if (this.closingTagParser.isClosingTag(mdNode.content)) {
                return this.standardizeClosingHTMLTag(mdNode, ont, file, line);
            }
            else {
                return this.standardizeHTMLBlock(mdNode, ont, file, line);
            }
        }
        // handle opening tags
        if (mdNode.type.endsWith("_open")) {
            return this.standardizeOpeningNode(mdNode, file, line, ont);
        }
        // handle closing tags
        if (mdNode.type.endsWith("_close")) {
            return this.standardizeClosingNode(mdNode, file, line, ont);
        }
        // handle text nodes
        if (mdNode.type === "text") {
            return this.standardizeTextNode(mdNode, file, line);
        }
        // handle stand-alone tags
        if (this.tagMapper.isStandaloneTag(mdNode.tag)) {
            return this.standizeStandaloneTag(mdNode, file, line);
        }
        throw new Error(`unknown MarkdownIt node: ${util_1.default.inspect(mdNode)}`);
    }
    standardizeImageNode(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        const attributes = standardizeMarkdownItAttributes(mdNode.attrs);
        for (const childNode of mdNode.children) {
            attributes.alt += childNode.content;
        }
        result.push(new ast_node_1.AstNode({
            attributes,
            content: "",
            file,
            line,
            tag: "img",
            type: "image"
        }));
        return result;
    }
    standardizeHeadingOpen(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: "",
            file,
            line,
            tag: mdNode.tag,
            type: `${mdNode.tag}_open`
        }));
        return result;
    }
    standardizeHeadingClose(node, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(node.attrs),
            content: "",
            file,
            line,
            tag: "/" + node.tag,
            type: `${node.tag}_close`
        }));
        return result;
    }
    standardizeCodeInline(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: "",
            file,
            line,
            tag: "code",
            type: "code_open"
        }));
        result.push(new ast_node_1.AstNode({
            attributes: {},
            content: mdNode.content,
            file,
            line,
            tag: "",
            type: "text"
        }));
        result.push(new ast_node_1.AstNode({
            attributes: {},
            content: "",
            file,
            line,
            tag: "/code",
            type: "code_close"
        }));
        return result;
    }
    standardizeEmbeddedCodeblock(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: "",
            file,
            line,
            tag: "pre",
            type: "fence_open"
        }));
        result.push(new ast_node_1.AstNode({
            attributes: {},
            content: mdNode.content.trim(),
            file,
            line,
            tag: "",
            type: "text"
        }));
        result.push(new ast_node_1.AstNode({
            attributes: {},
            content: "",
            file,
            line: mdNode.map[1],
            tag: "/pre",
            type: "fence_close"
        }));
        return result;
    }
    standardizeFence(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: "",
            file,
            line,
            tag: "pre",
            type: "fence_open"
        }));
        result.push(new ast_node_1.AstNode({
            attributes: {},
            content: mdNode.content.trim(),
            file,
            line: line + 1,
            tag: "",
            type: "text"
        }));
        result.push(new ast_node_1.AstNode({
            attributes: {},
            content: "",
            file,
            line: mdNode.map[1],
            tag: "/pre",
            type: "fence_close"
        }));
        return result;
    }
    standardizeClosingHTMLTag(mdNode, ont, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        const parsed = this.closingTagParser.parse(mdNode.content, file, line)[0];
        if (parsed.tag === "/a") {
            // </a> could be anchor_close or link_close, figure this out here
            if (ont.has("link_open")) {
                parsed.type = "link_close";
            }
            else if (ont.has("anchor_open")) {
                parsed.type = "anchor_close";
            }
            else {
                throw new Error("Found neither open link nor anchor");
            }
        }
        ont.close({ type: parsed.type }, file, line);
        result.push(parsed);
        return result;
    }
    standardizeHTMLBlock(mdNode, ont, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        const parsed = this.htmlParser.parse(mdNode.content, file, line);
        for (const node of parsed) {
            if (node.type.endsWith("_open")) {
                ont.open(node);
            }
            if (node.type.endsWith("_close")) {
                ont.close(node, file, line);
            }
        }
        result.push(...parsed);
        return result;
    }
    standardizeOpeningNode(mdNode, file, line, ont) {
        const result = new ast_node_list_1.AstNodeList();
        ont.open(mdNode);
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: mdNode.content.trim(),
            file,
            line,
            tag: this.tagMapper.tagForType(mdNode.type),
            type: mdNode.type
        }));
        return result;
    }
    standardizeClosingNode(mdNode, file, line, ont) {
        const result = new ast_node_list_1.AstNodeList();
        const openingNode = ont.close(mdNode, file, line);
        let closingTagLine = line;
        if (openingNode.map) {
            closingTagLine = openingNode.map[1];
        }
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: mdNode.content.trim(),
            file,
            line: closingTagLine,
            tag: this.tagMapper.tagForType(mdNode.type),
            type: mdNode.type
        }));
        return result;
    }
    standardizeTextNode(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: mdNode.content.trim(),
            file,
            line,
            tag: this.tagMapper.tagForType(mdNode.type),
            type: mdNode.type
        }));
        return result;
    }
    standizeStandaloneTag(mdNode, file, line) {
        const result = new ast_node_list_1.AstNodeList();
        result.push(new ast_node_1.AstNode({
            attributes: standardizeMarkdownItAttributes(mdNode.attrs),
            content: mdNode.content.trim(),
            file,
            line,
            tag: mdNode.tag,
            type: mdNode.type
        }));
        return result;
    }
}
exports.MarkdownParser = MarkdownParser;
/** returns the given attributes from a MarkdownIt node in the standard AST format */
function standardizeMarkdownItAttributes(attrs) {
    const result = {};
    if (attrs) {
        for (const [name, value] of attrs) {
            result[name] = value;
        }
    }
    return result;
}
exports.standardizeMarkdownItAttributes = standardizeMarkdownItAttributes;
//# sourceMappingURL=md-parser.js.map