"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const humanize_string_1 = __importDefault(require("humanize-string"));
const util_1 = __importDefault(require("util"));
const action_finder_1 = require("../actions/action-finder");
const printed_user_error_1 = require("../errors/printed-user-error");
const name_refiner_1 = require("./helpers/name-refiner");
const output_collector_1 = require("./helpers/output-collector");
async function runActivity(activity, configuration, linkTargets, statsCounter, formatter) {
    const outputCollector = new output_collector_1.OutputCollector();
    const nameRefiner = new name_refiner_1.NameRefiner(humanize_string_1.default(activity.actionName));
    const args = {
        SKIPPING: 1,
        configuration,
        file: activity.file.platformified(),
        line: activity.line,
        linkTargets,
        log: outputCollector.logFn(),
        name: nameRefiner.refineFn(),
        nodes: activity.nodes
    };
    try {
        const action = action_finder_1.actionFinder.actionFor(activity);
        let result;
        if (action.length === 1) {
            result = await runSyncOrPromiseFunc(action, args);
        }
        else {
            result = await runCallbackFunc(action, args);
        }
        if (result === undefined) {
            statsCounter.success();
            formatter.success(activity, nameRefiner.finalName(), outputCollector.toString());
        }
        else if (result === args.SKIPPING) {
            statsCounter.skip();
            formatter.skipped(activity, nameRefiner.finalName(), outputCollector.toString());
        }
        else {
            throw new Error(`unknown return code from action: ${result}`);
        }
    }
    catch (err) {
        statsCounter.error();
        if (isUserError(err)) {
            formatter.failed(activity, nameRefiner.finalName(), err, outputCollector.toString());
            return new printed_user_error_1.PrintedUserError(err);
        }
        else {
            // here we have a developer error like for example TypeError
            return err;
        }
    }
    return null;
}
exports.runActivity = runActivity;
async function runCallbackFunc(func, args) {
    const promisified = util_1.default.promisify(func);
    return promisified(args);
}
async function runSyncOrPromiseFunc(func, args) {
    const result = await Promise.resolve(func(args));
    return result;
}
function isUserError(err) {
    return err.name === "Error";
}
//# sourceMappingURL=run-activity.js.map