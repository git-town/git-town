"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const colorette_1 = __importDefault(require("colorette"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const got_1 = __importDefault(require("got"));
const path_1 = __importDefault(require("path"));
const absolute_file_path_1 = require("../../filesystem/absolute-file-path");
const unknown_link_1 = require("../../filesystem/unknown-link");
const remove_leading_slash_1 = require("../../helpers/remove-leading-slash");
const is_external_link_1 = require("../helpers/is-external-link");
const is_link_to_anchor_in_other_file_1 = require("../helpers/is-link-to-anchor-in-other-file");
const is_link_to_anchor_in_same_file_1 = require("../helpers/is-link-to-anchor-in-same-file");
const is_mailto_link_1 = require("../helpers/is-mailto-link");
/** The "checkLink" action checks for broken hyperlinks. */
async function checkLink(args) {
    const target = args.nodes.getNodeOfTypes("link_open").attributes.href;
    if (target == null || target === "") {
        throw new Error("link without target");
    }
    args.name(`link to ${colorette_1.default.cyan(target)}`);
    const filePath = new absolute_file_path_1.AbsoluteFilePath(args.file);
    if (is_mailto_link_1.isMailtoLink(target)) {
        return args.SKIPPING;
    }
    if (is_link_to_anchor_in_same_file_1.isLinkToAnchorInSameFile(target)) {
        const result = await checkLinkToAnchorInSameFile(filePath, target, args);
        return result;
    }
    if (is_link_to_anchor_in_other_file_1.isLinkToAnchorInOtherFile(target)) {
        const result = await checkLinkToAnchorInOtherFile(filePath, target, args);
        return result;
    }
    if (is_external_link_1.isExternalLink(target)) {
        const result = await checkExternalLink(target, args);
        return result;
    }
    await checkLinkToFilesystem(target, args);
    return;
}
exports.default = checkLink;
async function checkExternalLink(target, args) {
    if (args.configuration.offline) {
        return args.SKIPPING;
    }
    try {
        args.name(`link to external website ${colorette_1.default.cyan(target)}`);
        await got_1.default(target, { timeout: 4000 });
    }
    catch (err) {
        if (err.statusCode === 404 || err.code === "ENOTFOUND") {
            args.log("external website doesn't exist");
        }
        else if (err instanceof got_1.default.TimeoutError) {
            args.log("timed out");
        }
        else {
            args.log(`error while checking link to ${colorette_1.default.cyan(target)}: ${err.message}`);
        }
    }
    return;
}
async function checkLinkToFilesystem(target, args) {
    const unknownLink = new unknown_link_1.UnknownLink(decodeURI(target));
    const absoluteLink = unknownLink.absolutify(new absolute_file_path_1.AbsoluteFilePath(args.file), args.configuration.publications);
    const linkedFile = absoluteLink.localize(args.configuration.publications, args.configuration.defaultFile);
    const fullPath = path_1.default.join(args.configuration.sourceDir, linkedFile.platformified());
    // We only check for directories if no defaultFile is set.
    // Otherwise links to folders point to the default file.
    if (!args.configuration.defaultFile) {
        try {
            const stats = await fs_extra_1.default.stat(fullPath);
            if (stats.isDirectory()) {
                args.name(`link to local directory ${colorette_1.default.cyan(linkedFile.platformified())}`);
                return;
            }
        }
        catch (e) {
            // we can ignore errors here since we keep checking the file below
        }
    }
    args.name(`link to local file ${colorette_1.default.cyan(linkedFile.platformified())}`);
    try {
        await fs_extra_1.default.stat(fullPath);
    }
    catch (err) {
        throw new Error(`link to non-existing local file ${colorette_1.default.bold(linkedFile.platformified())}`);
    }
}
async function checkLinkToAnchorInSameFile(containingFile, target, args) {
    const anchorName = target.substr(1);
    if (!args.linkTargets.hasAnchor(containingFile, anchorName)) {
        throw new Error(`link to non-existing local anchor ${colorette_1.default.bold(target)}`);
    }
    if (args.linkTargets.anchorType(containingFile, anchorName) === "heading") {
        args.name(`link to local heading ${colorette_1.default.cyan(target)}`);
    }
    else {
        args.name(`link to #${colorette_1.default.cyan(anchorName)}`);
    }
}
async function checkLinkToAnchorInOtherFile(containingFile, target, args) {
    const link = new unknown_link_1.UnknownLink(target);
    const absoluteLink = link.absolutify(containingFile, args.configuration.publications);
    const filePath = absoluteLink.localize(args.configuration.publications, args.configuration.defaultFile);
    const anchorName = absoluteLink.anchor();
    if (!args.linkTargets.hasFile(filePath)) {
        throw new Error(`link to anchor #${colorette_1.default.cyan(anchorName)} in non-existing file ${colorette_1.default.cyan(remove_leading_slash_1.removeLeadingSlash(filePath.platformified()))}`);
    }
    if (!args.linkTargets.hasAnchor(filePath, anchorName)) {
        throw new Error(`link to non-existing anchor ${colorette_1.default.bold("#" + anchorName)} in ${colorette_1.default.bold(filePath.platformified())}`);
    }
    if (args.linkTargets.anchorType(filePath, anchorName) === "heading") {
        args.name(`link to heading ${colorette_1.default.cyan(filePath.platformified() + "#" + anchorName)}`);
    }
    else {
        args.name(`link to ${colorette_1.default.cyan(filePath.platformified())}#${colorette_1.default.cyan(anchorName)}`);
    }
}
//# sourceMappingURL=check-link.js.map