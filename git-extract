#!/bin/bash
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/helpers/helpers.sh"


# The path to the abort script
abort_script="/tmp/git_extract_abort$temp_filename_suffix"


# Called when the cherry-pick causes an error
function error_cherry_pick {
  # Create the abort file.
  echo "git cherry-pick --abort" > $abort_script
  echo "git checkout $initial_branch_name" >> $abort_script
  echo "git branch -D $1" >> $abort_script
  if [ $initial_open_changes == true ]; then
    echo "git stash pop" >> $abort_script
  fi

  # Show error message.
  echo
  echo_red 'To abort the cherry-pick and check out the original branch, run "git extract --abort".'
  exit_with_error
}


# Called by pull_branch when the merge fails with conflicts
function error_pull_main_branch {
  # Create the abort file.
  echo "git rebase --abort" > $abort_script
  echo "git checkout $initial_branch_name" >> $abort_script
  if [ $initial_open_changes == true ]; then
    echo "git stash pop" >> $abort_script
  fi

  # Show error message.
  echo
  echo_red 'To abort the rebase and check out the original branch, run "git extract --abort".'
  exit_with_error
}


# Performs the extract operation
function perform_extract {
  local target_branch_name=$1
  local user_input=$2
  stash_open_changes
  sync_main_branch

  if [ "$user_input" == "" ]; then
    git log $main_branch_name..$initial_branch_name                    | # Get a list of all commits in the feature branch.
      grep -v '^$'                                                     | # Remove empty lines.
      grep -v '^Author: '                                              | # Remove the lines that contain the authors of a commit.
      grep -v '^Date: '                                                | # Remove the lines that contain the date of a commit.
      awk '{ sub(/^[ ]{4}/, ""); print }'                              | # Remove the first 4 spaces from commit messages
      awk '{ sub(/^commit /, ""); print }'                             | # Remove the word 'commit' from the lines that contain the commit SHA.
      awk '{ if (NR % 2 == 0) print "\047" $0 "\047"; else print }'    | # Surround the commit messages in quotes.
      awk '{ if (NR % 2 == 0) print ; else print substr($0, 0, 10) }'  | # Truncate the SHA1s to 10 characters.
      awk 'ORS=NR%2?" ":"\n"'                                          | # Concatenate every 2 lines into one line, so we get the first 2 options required by dialog for each entry.
      awk '{ print $0 " off" }'                                        | # Append ' off' to each line. This is the third option required by dialog for each entry.
      tail -r                                                          | # Reverse the order of lines.
      xargs dialog --title "Please select all commits to be extracted from the '$initial_branch_name' branch into the '$1' branch" --ok-label "Extract" --cancel-label "Abort" --checklist "" 0 0 0  2> $user_input_filename   # Ask the user for commits
    clear
  else
    echo $user_input > $user_input_filename
  fi

  if [ ! -s $user_input_filename ]; then
    echo_error_header
    echo_error "Nothing selected, aborting script."
    exit_with_error
  fi

  create_feature_branch $target_branch_name
  cherry_pick `cat $user_input_filename`

  delete_temp_file
  push_branch
  restore_open_changes
}


# Aborts a currently ongoing sync
function abort_extract {
  if [ -f $abort_script ]; then
    source $abort_script
    rm $abort_script
  else
    echo_red "Cannot find abort definition file"
  fi
}


# Exit with a help screen if parameters are missing.
if [ -z $1 ]; then
  echo_usage_header
  echo_usage "git extract [name of the new branch to create]"
  exit_with_error
fi

ensure_on_feature_branch "You must be on a feature branch in order to extract commits."

if [ "$1" == "--abort" ]; then
  abort_extract "$@"
else
  if [ -z $2 ]; then
    ensure_tool_installed 'dialog'
  fi
  perform_extract "$@"
fi

exit_with_success
