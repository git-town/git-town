package proposallineage

import (
	"strings"

	"github.com/git-town/git-town/v22/internal/forge/forgedomain"
	"github.com/git-town/git-town/v22/internal/git/gitdomain"
)

const spacesPerIndent = 2

func RenderTree(tree TreeNodeWithProposal, currentBranch gitdomain.LocalBranchName, direction forgedomain.ProposalBreadcrumbDirection, style forgedomain.ProposalBreadcrumbStyle) string {
	var builder strings.Builder
	builder.WriteString("\n-------------------------\n")

	flat := style == forgedomain.ProposalBreadcrumbStyleAuto && tree.IsLinear()

	switch direction {
	case forgedomain.ProposalBreadcrumbDirectionTopDown:
		renderNodeTopDown(&builder, tree, currentBranch, 0, false, flat)
	case forgedomain.ProposalBreadcrumbDirectionBottomUp:
		maxDepth := tree.MaxDepth()
		renderNodeBottomUp(&builder, tree, currentBranch, maxDepth, flat)
	}

	builder.WriteString("\n<sup>[Stack](https://www.git-town.com/how-to/proposal-breadcrumb.html) generated by [Git Town](https://github.com/git-town/git-town)</sup>\n")
	return builder.String()
}

func renderNodeBottomUp(builder *strings.Builder, node TreeNodeWithProposal, currentBranch gitdomain.LocalBranchName, maxDepth int, flat bool) bool {
	// First render children (they appear at top in bottom-up)
	// foundCurrent propagates UP from children to parents
	childFoundCurrent := false
	for _, child := range node.Children {
		if renderNodeBottomUp(builder, child, currentBranch, maxDepth, flat) {
			childFoundCurrent = true
		}
	}
	isCurrentBranch := node.Branch == currentBranch
	// In bottom-up: if childFoundCurrent or isCurrentBranch, we're on the path from current to root
	onPathToRoot := childFoundCurrent || isCurrentBranch
	// Render if: has proposal/descendant with proposal, OR on path from current to root
	if node.BranchOrAncestorHasProposal() || onPathToRoot {
		depth := node.Depth(maxDepth)
		indent := 0
		if !flat {
			indent = depth * spacesPerIndent
		}
		builder.WriteString(strings.Repeat(" ", indent))
		builder.WriteString("- ")
		if proposal, hasProposal := node.Proposal.Get(); hasProposal {
			builder.WriteString(proposal.Data.Data().URL)
		} else {
			builder.WriteString(node.Branch.String())
		}
		if isCurrentBranch {
			builder.WriteString(" :point_left:")
		}
		builder.WriteString("\n")
	}
	return onPathToRoot
}

func renderNodeTopDown(builder *strings.Builder, node TreeNodeWithProposal, currentBranch gitdomain.LocalBranchName, depth int, foundCurrent bool, flat bool) {
	if node.BranchOrAncestorHasProposal() || !foundCurrent {
		indent := 0
		if !flat {
			indent = depth * spacesPerIndent
		}
		builder.WriteString(strings.Repeat(" ", indent))
		builder.WriteString("- ")
		if proposal, hasProposal := node.Proposal.Get(); hasProposal {
			builder.WriteString(proposal.Data.Data().URL)
		} else {
			builder.WriteString(node.Branch.String())
		}
		isCurrentBranch := node.Branch == currentBranch && !foundCurrent
		if isCurrentBranch {
			builder.WriteString(" :point_left:")
			foundCurrent = true
		}
		builder.WriteString("\n")
	}
	for _, child := range node.Children {
		renderNodeTopDown(builder, child, currentBranch, depth+1, foundCurrent, flat)
	}
}
